--
-- PostgreSQL database dump
--

-- Dumped from database version 11.5
-- Dumped by pg_dump version 11.5

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Data for Name: ALGORITHM; Type: TABLE DATA; Schema: public; Owner: -
--

INSERT INTO public."ALGORITHM" VALUES (2, 'DecisionTreeRegressor', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeRegressor.html', 'tree', 'DecisionTreeRegressor', 'Decision Tree for Regression', 'regression', '[{''name'':''criterion'', ''default'':''mse'', ''type'':''string'', ''note'':''분할의 질을 측정하는 함수 mse,friedman_mse,mae'', ''enumeration'':''mse,friedman_mse,mae''}, {''name'':''splitter'', ''default'':''best'', ''type'':''string'', ''note'':''노드의 분할을 결정하는 방법 best,random'', ''enumeration'':''best,random''}, {''name'':''max_depth'', ''default'':''None'', ''type'':''int'', ''note'':''트리의 최대 깊이 '', ''enumeration'':''''}, {''name'':''min_samples_split'', ''default'':''2'', ''type'':''int, float'', ''note'':''내부 노드를 분할 하는데 필요한 최소 샘플 수 '', ''enumeration'':''''}, {''name'':''min_samples_leaf'', ''default'':''1'', ''type'':''int, float'', ''note'':''잎사귀 노드가 요구하는 최소 샘플 수 '', ''enumeration'':''''}, {''name'':''min_weight_fraction_leaf'', ''default'':''0'', ''type'':''float'', ''note'':''잎사귀 노드에 있어야 하는 (모든 입력 샘플의) 총 가중치의 최소 가중 비율 '', ''enumeration'':''''}, {''name'':''max_features'', ''default'':''None'', ''type'':''int, float,string'', ''note'':''최적의 분할을 찾을 때 고려해야 할 features 수 auto,sqrt,log2,None'', ''enumeration'':''auto,sqrt,log2,None''}, {''name'':''random_state'', ''default'':''None'', ''type'':''int'', ''note'':''int는 난수 생성기에서 사용하는 seed, 만약 None이면 난수 생성기는 np.random에서 사용하는 인스턴스를 사용 '', ''enumeration'':''''}, {''name'':''max_leaf_nodes'', ''default'':''None'', ''type'':''int'', ''note'':''잎사귀 노드의 성장 상한선 '', ''enumeration'':''''}, {''name'':''min_impurity_decrease'', ''default'':''0'', ''type'':''float'', ''note'':''분할이 impurity을 지정한 값 이상으로 감소시키면 노드 분할 '', ''enumeration'':''''}, {''name'':''min_impurity_split'', ''default'':''0.0000001'', ''type'':''float'', ''note'':''나무의 빠른 중단에 대한 임계값 '', ''enumeration'':''''}, {''name'':''presort'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''최적의 분할을 찾는 속도를 높이기 위해 데이터를 미리 정렬할지에 대한 여부 '', ''enumeration'':''''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like'', ''note'':''대상 값 [n_samples], [n_samples, n_outputs]''}, {''name'':''sample_weight'', ''default'':''None'', ''type'':''array-like'', ''note'':''샘플의 가중치, None일 경우 샘플들은 같은 가중치를 갖음 [n_samples], None''}, {''name'':''check_input'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''input checking의 우회 여부 ''}, {''name'':''X_idx_sorted'', ''default'':''None'', ''type'':''array-like'', ''note'':''정렬된 학습용 입력 샘플의 색인 [n_samples, n_features]''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);
INSERT INTO public."ALGORITHM" VALUES (3, 'SVC', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html', 'svm', 'SVC', 'Support Vecter Classification', 'classification', '[{''name'':''C'', ''default'':''1'', ''type'':''float'', ''note'':''에러 항의 패널티 매개 변수 '', ''enumeration'':''''}, {''name'':''kernel'', ''default'':''rbf'', ''type'':''string'', ''note'':''알고리즘에 사용될 커널 유형 linear,poly,rbf,sigmoid,precomputed'', ''enumeration'':''linear,poly,rbf,sigmoid,precomputed''}, {''name'':''degree'', ''default'':''3'', ''type'':''int'', ''note'':''다항식 커널 함수(poly)의 Degree(다른 모든 커널에서는 무시 '', ''enumeration'':''''}, {''name'':''gamma'', ''default'':''auto_deprecated'', ''type'':''float'', ''note'':''rbf, poly, sigmoid에 대한 커널 계수 '', ''enumeration'':''''}, {''name'':''coef0'', ''default'':''0'', ''type'':''float'', ''note'':''커널함수에서 독립적인 항(poly와 sigmoid에서만 중요함) '', ''enumeration'':''''}, {''name'':''shrinking'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''축소 휴리스틱 사용 여부 '', ''enumeration'':''''}, {''name'':''probability'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''확률 추정을 활성화할지 여부 '', ''enumeration'':''''}, {''name'':''tol'', ''default'':''0.001'', ''type'':''float'', ''note'':''중단에 대한 허용 오차 '', ''enumeration'':''''}, {''name'':''cache_size'', ''default'':''200'', ''type'':''float'', ''note'':''커널 캐시의 크기를 MB단위로 지정 '', ''enumeration'':''''}, {''name'':''class_weight'', ''default'':''None'', ''type'':''dict, string'', ''note'':''SVC의 경우 클래스 I 의 매개 변수 C를 class_weight[i]*C로 설정 dict,balanced'', ''enumeration'':''dict,balanced''}, {''name'':''verbose'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''자세한 출력 활성화 '', ''enumeration'':''''}, {''name'':''max_iter'', ''default'':''-1'', ''type'':''int'', ''note'':''solver 내 iteration에 대한 제한 또는 제한이 없는 경우 -1 '', ''enumeration'':''''}, {''name'':''decision_function_shape'', ''default'':''ovr'', ''type'':''string'', ''note'':''(n_samples, n_classes)의 모양을 반환하는 ovr 결정함수를 쓸지 (n_samples, n_classes * (n_classes - 1) / 2)의 모양을 반환하는 ovo 결정함수를 쓸지에 대한 여부 ovo,ovr'', ''enumeration'':''ovo,ovr''}, {''name'':''random_state'', ''default'':''None'', ''type'':''int'', ''note'':''확률 추정을 위해 데이터를 섞을 때 사용되는 의사 난수 생성기의 시드 '', ''enumeration'':''''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like'', ''note'':''대상 값 [n_samples]''}, {''name'':''sample_weight'', ''default'':''None'', ''type'':''array-like'', ''note'':''각 샘플의 가중치 [n_samples], None''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);
INSERT INTO public."ALGORITHM" VALUES (4, 'SVR', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVR.html', 'svm', 'SVR', 'Support Vecter Regression', 'regression', '[{''name'':''kernel'', ''default'':''rbf'', ''type'':''string'', ''note'':''알고리즘에 사용될 커널 유형 linear,poly,rbf,sigmoid,precomputed'', ''enumeration'':''linear,poly,rbf,sigmoid,precomputed''}, {''name'':''degree'', ''default'':''3'', ''type'':''int'', ''note'':''다항식 커널 함수(poly)의 Degree(다른 모든 커널에서는 무시) '', ''enumeration'':''''}, {''name'':''gamma'', ''default'':''auto_deprecated'', ''type'':''float'', ''note'':''rbf, poly, sigmoid에 대한 커널 계수 '', ''enumeration'':''''}, {''name'':''coef0'', ''default'':''0'', ''type'':''float'', ''note'':''커널함수에서 독립적인 항(poly와 sigmoid에서만 중요함) '', ''enumeration'':''''}, {''name'':''tol'', ''default'':''0.001'', ''type'':''float'', ''note'':''중단에 대한 허용 오차 '', ''enumeration'':''''}, {''name'':''C'', ''default'':''1'', ''type'':''float'', ''note'':''에러 항의 패널티 매개 변수 '', ''enumeration'':''''}, {''name'':''epsilon'', ''default'':''0.1'', ''type'':''float'', ''note'':''SVR모델의 엡실론 '', ''enumeration'':''''}, {''name'':''shrinking'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''축소 휴리스틱 사용 여부 '', ''enumeration'':''''}, {''name'':''cache_size'', ''default'':''200'', ''type'':''float'', ''note'':''커널 캐시의 크기를 MB단위로 지정 '', ''enumeration'':''''}, {''name'':''verbose'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''자세한 출력 활성화 '', ''enumeration'':''''}, {''name'':''max_iter'', ''default'':''-1'', ''type'':''int'', ''note'':''solver 내 iteration에 대한 제한 또는 제한이 없는 경우 -1 '', ''enumeration'':''''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like'', ''note'':''대상 값 [n_samples]''}, {''name'':''sample_weight'', ''default'':''None'', ''type'':''array-like'', ''note'':''각 샘플의 가중치 [n_samples], None''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);
INSERT INTO public."ALGORITHM" VALUES (5, 'KNeighborsClassifier', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html', 'neighbors', 'KNeighborsClassifier', 'Classifier implementing the K-nearest neighbors vote.', 'classification', '[{''name'':''n_neighbors'', ''default'':''5'', ''type'':''int'', ''note'':''kneighbors 쿼리에 기본적으로 사용할 이웃 수 '', ''enumeration'':''''}, {''name'':''weights'', ''default'':''uniform'', ''type'':''string'', ''note'':''예측에 사용되는 가중치 함수 uniform,distance,[callback]'', ''enumeration'':''uniform,distance,[callback]''}, {''name'':''algorithm'', ''default'':''auto'', ''type'':''string'', ''note'':''가장 가까운 이웃을 계산하는데 사용되는 알고리즘 auto,ball_tree,kd_tree,brute'', ''enumeration'':''auto,ball_tree,kd_tree,brute''}, {''name'':''leaf_size'', ''default'':''30'', ''type'':''int'', ''note'':''잎의 크기는 BallTree나 KDTree에 전달 '', ''enumeration'':''''}, {''name'':''p'', ''default'':''2'', ''type'':''int'', ''note'':''Minkowski 메트릭의 Power 매개 변수, 1일 경우 manhattan거리 2일 경우 euclidean거리 사용 '', ''enumeration'':''''}, {''name'':''metric'', ''default'':''minkowski'', ''type'':''string'', ''note'':''트리에 사용할 거리 측정 항목 minkowski,euclidean,manhattan,chebyshev,wminkowski,seuclidean,mahalanobis'', ''enumeration'':''minkowski,euclidean,manhattan,chebyshev,wminkowski,seuclidean,mahalanobis''}, {''name'':''metric_params'', ''default'':''None'', ''type'':''dict'', ''note'':''메트릭 함수에 대한 추가 키워드 인수 '', ''enumeration'':''''}, {''name'':''n_jobs'', ''default'':''None'', ''type'':''int'', ''note'':''병렬 작업의 수 '', ''enumeration'':''''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''대상 값 [n_samples], [n_samples, n_outputs]''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);
INSERT INTO public."ALGORITHM" VALUES (7, 'LinearRegression', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html', 'linear_model', 'LinearRegression', 'Ordinary least squares linear regression', 'regression', '[{''name'':''fit_intercept'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''절편을 계산할지 여부 '', ''enumeration'':''''}, {''name'':''normalize'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''True인 경우 회귀 X는 평균을 빼고 l2-norm으로 나누어 회귀 전에 정규화, fit_intercept가 False인 경우 무시 '', ''enumeration'':''''}, {''name'':''copy_X'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''True인 경우 X가 복사, 그렇지 않으면 덮어쓸 수 있음 '', ''enumeration'':''''}, {''name'':''n_jobs'', ''default'':''None'', ''type'':''int'', ''note'':''계산에 사용할 작업 수, n_targets > 1 이며 충분히 큰 문제에서 속도를 향상 '', ''enumeration'':''''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like'', ''note'':''대상 값 [n_samples, n_targets]''}, {''name'':''sample_weight'', ''default'':''None'', ''type'':''array-like'', ''note'':''각 샘플의 가중치 [n_samples], None''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);
INSERT INTO public."ALGORITHM" VALUES (8, 'Ridge', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html', 'linear_model', 'Ridge', 'Linear least squares with l2 regularization.', 'regression', '[{''name'':''alpha'', ''default'':''1'', ''type'':''float, array-like'', ''note'':''정규화 강도, 값이 클수록 더 정규화 '', ''enumeration'':''''}, {''name'':''fit_intercept'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''절편을 계산할지 여부 '', ''enumeration'':''''}, {''name'':''normalize'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''True인 경우 회귀 X는 평균을 빼고 l2-norm으로 나누어 회귀 전에 정규화, fit_intercept가 False인 경우 무시 '', ''enumeration'':''''}, {''name'':''copy_X'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''True인 경우 X가 복사, 그렇지 않으면 덮어쓸 수 있음 '', ''enumeration'':''''}, {''name'':''max_iter'', ''default'':''None'', ''type'':''int'', ''note'':''켤레 그레디언트 솔버의 최대 반복 횟수 '', ''enumeration'':''''}, {''name'':''tol'', ''default'':''0.001'', ''type'':''float'', ''note'':''솔루션의 precision '', ''enumeration'':''''}, {''name'':''solver'', ''default'':''auto'', ''type'':''string'', ''note'':''계산 루틴에서 사용할 솔버 auto,svd,cholesky,lsqr,sparse_cg,sag,saga'', ''enumeration'':''auto,svd,cholesky,lsqr,sparse_cg,sag,saga''}, {''name'':''random_state'', ''default'':''None'', ''type'':''int'', ''note'':''확률 추정을 위해 데이터를 섞을 때 사용되는 의사 난수 생성기의 시드, int는 난수 생성기에서 사용하는 seed, 만약 None이면 난수 생성기는 np.random에서 사용하는 인스턴스를 사용 '', ''enumeration'':''''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like'', ''note'':''대상 값 [n_samples], [n_samples, n_targets]''}, {''name'':''sample_weight'', ''default'':''None'', ''type'':''float, array-like'', ''note'':''각 샘플의 가중치 [n_samples], None''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);
INSERT INTO public."ALGORITHM" VALUES (10, 'RandomForestClassifier', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html', 'ensemble', 'RandomForestClassifier', 'A random forest classifier', 'classification', '[{''name'':''n_estimators'', ''default'':''10'', ''type'':''int'', ''note'':''Tree의 수 '', ''enumeration'':''''}, {''name'':''criterion'', ''default'':''gini'', ''type'':''string'', ''note'':''분할의 질을 측정하는 함수 gini,entropy'', ''enumeration'':''gini,entropy''}, {''name'':''max_depth'', ''default'':''None'', ''type'':''int'', ''note'':''Tree의 최대 깊이 '', ''enumeration'':''''}, {''name'':''min_samples_split'', ''default'':''2'', ''type'':''int, float'', ''note'':''내부 노드를 분할 하는데 필요한 최소 샘플 수 '', ''enumeration'':''''}, {''name'':''min_samples_leaf'', ''default'':''1'', ''type'':''int, float'', ''note'':''잎사귀 노드가 요구하는 최소 샘플 수 '', ''enumeration'':''''}, {''name'':''min_weight_fraction_leaf'', ''default'':''0'', ''type'':''float'', ''note'':''잎사귀 노드에 있어야 하는 (모든 입력 샘플의) 총 가중치의 최소 가중 비율 '', ''enumeration'':''''}, {''name'':''max_features'', ''default'':''auto'', ''type'':''int, float, string'', ''note'':''최적의 분할을 찾을 때 고려해야 할 features 수 auto,sqrt,log2,None'', ''enumeration'':''auto,sqrt,log2,None''}, {''name'':''max_leaf_nodes'', ''default'':''None'', ''type'':''int'', ''note'':''잎사귀 노드의 성장 상한선 '', ''enumeration'':''''}, {''name'':''min_impurity_decrease'', ''default'':''0'', ''type'':''float'', ''note'':''분할이 impurity을 지정한 값 이상으로 감소시키면 노드 분할 '', ''enumeration'':''''}, {''name'':''min_impurity_split'', ''default'':''None'', ''type'':''float'', ''note'':''나무의 빠른 중단에 대한 임계값 '', ''enumeration'':''''}, {''name'':''bootstrap'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''Tree를 만들때 bootstrap 사용 여부 '', ''enumeration'':''''}, {''name'':''oob_score'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''일반화 정확도를 평가하기 위해 oob 샘플을 사용 여부 '', ''enumeration'':''''}, {''name'':''n_jobs'', ''default'':''None'', ''type'':''int'', ''note'':''fit과 predict에 대해 병렬로 실행되는 작업의 수 '', ''enumeration'':''''}, {''name'':''random_state'', ''default'':''None'', ''type'':''int'', ''note'':''확률 추정을 위해 데이터를 섞을 때 사용되는 의사 난수 생성기의 시드, int는 난수 생성기에서 사용하는 seed, 만약 None이면 난수 생성기는 np.random에서 사용하는 인스턴스를 사용 '', ''enumeration'':''''}, {''name'':''verbose'', ''default'':''0'', ''type'':''int'', ''note'':''fitting과 predicting할 때 자세한 출력 활성화 '', ''enumeration'':''''}, {''name'':''warm_start'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''True일 경우 이전 호출의 solution을 재사용해서 초기화 '', ''enumeration'':''''}, {''name'':''class_weight'', ''default'':''None'', ''type'':''dict, list of dicts, string'', ''note'':''{class_label : weight} 형식의 클래스와 연관된 가중치 balanced,balanced_subsample,None'', ''enumeration'':''balanced,balanced_subsample,None''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like'', ''note'':''대상 값 [n_samples], [n_samples, n_outputs]''}, {''name'':''samples_weight'', ''default'':''None'', ''type'':''array-like'', ''note'':''샘플의 가중치 [n_samples], None''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);
INSERT INTO public."ALGORITHM" VALUES (11, 'RandomForestRegressor', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html', 'ensemble', 'RandomForestRegressor', 'A random forest regressor', 'regression', '[{''name'':''n_estimators'', ''default'':''10'', ''type'':''int'', ''note'':''Tree의 수 '', ''enumeration'':''''}, {''name'':''criterion'', ''default'':''mse'', ''type'':''string'', ''note'':''분할의 질을 측정하는 함수 mse,mae'', ''enumeration'':''mse,mae''}, {''name'':''max_depth'', ''default'':''None'', ''type'':''int'', ''note'':''Tree의 최대 깊이 '', ''enumeration'':''''}, {''name'':''min_samples_split'', ''default'':''2'', ''type'':''int, float'', ''note'':''내부 노드를 분할 하는데 필요한 최소 샘플 수 '', ''enumeration'':''''}, {''name'':''min_samples_leaf'', ''default'':''1'', ''type'':''int, float'', ''note'':''잎사귀 노드가 요구하는 최소 샘플 수 '', ''enumeration'':''''}, {''name'':''min_weight_fraction_leaf'', ''default'':''0'', ''type'':''float'', ''note'':''잎사귀 노드에 있어야 하는 (모든 입력 샘플의) 총 가중치의 최소 가중 비율 '', ''enumeration'':''''}, {''name'':''max_features'', ''default'':''auto'', ''type'':''int, float, string'', ''note'':''최적의 분할을 찾을 때 고려해야 할 features 수 auto,sqrt,log2,None'', ''enumeration'':''auto,sqrt,log2,None''}, {''name'':''max_leaf_nodes'', ''default'':''None'', ''type'':''int'', ''note'':''잎사귀 노드의 성장 상한선 '', ''enumeration'':''''}, {''name'':''min_impurity_decrease'', ''default'':''0'', ''type'':''float'', ''note'':''분할이 impurity을 지정한 값 이상으로 감소시키면 노드 분할 '', ''enumeration'':''''}, {''name'':''min_impurity_split'', ''default'':''None'', ''type'':''float'', ''note'':''나무의 빠른 중단에 대한 임계값 '', ''enumeration'':''''}, {''name'':''bootstrap'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''Tree를 만들때 bootstrap 사용 여부 '', ''enumeration'':''''}, {''name'':''oob_score'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''보이지 않는 데이터에 대한 R^2를 추정하기 위해 oob 샘플을 사용 여부 '', ''enumeration'':''''}, {''name'':''n_jobs'', ''default'':''None'', ''type'':''int'', ''note'':''fit과 predict에 대해 병렬로 실행되는 작업의 수 '', ''enumeration'':''''}, {''name'':''random_state'', ''default'':''None'', ''type'':''int'', ''note'':''확률 추정을 위해 데이터를 섞을 때 사용되는 의사 난수 생성기의 시드, int는 난수 생성기에서 사용하는 seed, 만약 None이면 난수 생성기는 np.random에서 사용하는 인스턴스를 사용 '', ''enumeration'':''''}, {''name'':''verbose'', ''default'':''0'', ''type'':''int'', ''note'':''fitting과 predicting할 때 자세한 출력 활성화 '', ''enumeration'':''''}, {''name'':''warm_start'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''True일 경우 이전 호출의 solution을 재사용해서 초기화 '', ''enumeration'':''''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like'', ''note'':''대상 값 [n_samples], [n_samples, n_outputs]''}, {''name'':''sample_weight'', ''default'':''None'', ''type'':''array-like'', ''note'':''샘플의 가중치 [n_samples], None''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);
INSERT INTO public."ALGORITHM" VALUES (9, 'Lasso', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Lasso.html', 'linear_model', 'Lasso', 'Linear model trained with l1 prior as regularizer (aka the Lasso)', 'regression', '[{''name'':''alpha'', ''default'':''1'', ''type'':''float'', ''note'':''L1항을 곱하는 상수, 0일 경우 LinearRegression의 OLS와 같다. '', ''enumeration'':''''}, {''name'':''fit_intercept'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''절편을 계산할지 여부 '', ''enumeration'':''''}, {''name'':''nomalize'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''True인 경우 회귀 X는 평균을 빼고 l2-norm으로 나누어 회귀 전에 정규화, fit_intercept가 False인 경우 무시 '', ''enumeration'':''''}, {''name'':''percompute'', ''default'':''FALSE'', ''type'':''bool, array-like'', ''note'':''미리 계산 된 Gram 행렬을 사용하여 계산 속도를 높일 지 여부 '', ''enumeration'':''''}, {''name'':''copy_X'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''True인 경우 X가 복사, 그렇지 않으면 덮어쓸 수 있음 '', ''enumeration'':''''}, {''name'':''max_iter'', ''default'':''1000'', ''type'':''int'', ''note'':''최대 반복 횟수 '', ''enumeration'':''''}, {''name'':''tol'', ''default'':''0.0001'', ''type'':''float'', ''note'':''최적화에 대한 허용 오차 '', ''enumeration'':''''}, {''name'':''warm_start'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''True일 경우 이전 호출의 solution을 재사용해서 초기화 '', ''enumeration'':''''}, {''name'':''positive'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''True일 경우 계수를 양수로 만듬 '', ''enumeration'':''''}, {''name'':''random_state'', ''default'':''None'', ''type'':''int'', ''note'':''확률 추정을 위해 데이터를 섞을 때 사용되는 의사 난수 생성기의 시드, int는 난수 생성기에서 사용하는 seed, 만약 None이면 난수 생성기는 np.random에서 사용하는 인스턴스를 사용 '', ''enumeration'':''''}, {''name'':''selection'', ''default'':''cyclic'', ''type'':''string'', ''note'':''랜덤으로 설정하면 임의의 계수가 기본적으로 피쳐를 순차적으로 반복하지 않고 반복마다 업데이트 cyclic,random'', ''enumeration'':''cyclic,random''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like'', ''note'':''대상 값 [n_samples], [n_samples, n_targets]''}, {''name'':''check_input'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''input checking의 우회 여부 ''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);
INSERT INTO public."ALGORITHM" VALUES (13, 'AdaBoostRegressor', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostRegressor.html', 'ensemble', 'AdaBoostRegressor', 'An AdaBoost regressor.', 'regression', '[{''name'':''base_estimator'', ''default'':''None'', ''type'':''object'', ''note'':''부스트 앙상블이 만들어지는 기본 추정기, None일 경우 DecisionTreeClassifier(max_depth=1)이 기본 추정기 '', ''enumeration'':''''}, {''name'':''n_estimators'', ''default'':''50'', ''type'':''int'', ''note'':''부스팅이 종료되는 최대 추정량 '', ''enumeration'':''''}, {''name'':''learning_rate'', ''default'':''1'', ''type'':''float'', ''note'':''모델의 학습률 '', ''enumeration'':''''}, {''name'':''loss'', ''default'':''linear'', ''type'':''string'', ''note'':''각 부스팅 반복 후 가중치를 업데이트 할때 사용되는 손실 함수 linear,square,exponential'', ''enumeration'':''linear,square,exponential''}, {''name'':''random_state'', ''default'':''None'', ''type'':''int'', ''note'':''확률 추정을 위해 데이터를 섞을 때 사용되는 의사 난수 생성기의 시드, int는 난수 생성기에서 사용하는 seed, 만약 None이면 난수 생성기는 np.random에서 사용하는 인스턴스를 사용 '', ''enumeration'':''''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like'', ''note'':''대상 값 [n_samples]''}, {''name'':''sample_weight'', ''default'':''None'', ''type'':''array-like'', ''note'':''샘플의 가중치 [n_samples], None''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);
INSERT INTO public."ALGORITHM" VALUES (14, 'GradientBoostingClassifier', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingClassifier.html', 'ensemble', 'GradientBoostingClassifier', 'Gradient Boosting for classification', 'classification', '[{''name'':''loss'', ''default'':''deviance'', ''type'':''string'', ''note'':''deviance는 확률적 결과로 분류하기 위한 로지스틱 회귀를 나타냄, exponential은 손실에 대해 지수 그래디언트 부스팅으로 AdaBoost 알고리즘 복구 deviance,exponential'', ''enumeration'':''deviance,exponential''}, {''name'':''learning_rate'', ''default'':''0.1'', ''type'':''float'', ''note'':''학습률 '', ''enumeration'':''''}, {''name'':''n_estimators'', ''default'':''100'', ''type'':''int'', ''note'':''수행 할 부스팅 단계 수 '', ''enumeration'':''''}, {''name'':''subsample'', ''default'':''1'', ''type'':''float'', ''note'':''개별 기본 학습자를 맞추는 데 사용되는 샘플의 비율, 1보다 작으면 Stochastic Gradient Boosting '', ''enumeration'':''''}, {''name'':''criterion'', ''default'':''friedman_mse'', ''type'':''string'', ''note'':''분할의 질을 측정하는 함수 friedman_mse,mse,mae'', ''enumeration'':''friedman_mse,mse,mae''}, {''name'':''min_samples_split'', ''default'':''2'', ''type'':''int, float'', ''note'':''내부 노드를 분할 하는데 필요한 최소 샘플 수 '', ''enumeration'':''''}, {''name'':''min_samples_leaf'', ''default'':''1'', ''type'':''int, float'', ''note'':''잎사귀 노드가 요구하는 최소 샘플 수 '', ''enumeration'':''''}, {''name'':''min_weight_fraction_leaf'', ''default'':''0'', ''type'':''float'', ''note'':''잎사귀 노드에 있어야 하는 (모든 입력 샘플의) 총 가중치의 최소 가중 비율 '', ''enumeration'':''''}, {''name'':''max_depth'', ''default'':''3'', ''type'':''int'', ''note'':''개별 회귀 추정기의 최대 깊이 '', ''enumeration'':''''}, {''name'':''min_impurity_decrease'', ''default'':''0'', ''type'':''float'', ''note'':''분할이 impurity을 지정한 값 이상으로 감소시키면 노드 분할 '', ''enumeration'':''''}, {''name'':''min_impurity_split'', ''default'':''None'', ''type'':''float'', ''note'':''나무의 빠른 중단에 대한 임계값 '', ''enumeration'':''''}, {''name'':''init'', ''default'':''None'', ''type'':''string'', ''note'':''초기 예측을 계산하는데 사용되는 추정기 zero,None'', ''enumeration'':''zero,None''}, {''name'':''random_state'', ''default'':''None'', ''type'':''int'', ''note'':''확률 추정을 위해 데이터를 섞을 때 사용되는 의사 난수 생성기의 시드, int는 난수 생성기에서 사용하는 seed, 만약 None이면 난수 생성기는 np.random에서 사용하는 인스턴스를 사용 '', ''enumeration'':''''}, {''name'':''max_features'', ''default'':''None'', ''type'':''int, float, string'', ''note'':''최적의 분할을 찾을 때 고려해야 할 features 수 auto,sqrt,log2,None'', ''enumeration'':''auto,sqrt,log2,None''}, {''name'':''verbose'', ''default'':''0'', ''type'':''int'', ''note'':''자세한 출력 사용 '', ''enumeration'':''''}, {''name'':''max_leaf_nodes'', ''default'':''None'', ''type'':''int'', ''note'':''잎사귀 노드의 성장 상한선 '', ''enumeration'':''''}, {''name'':''warm_start'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''True일 경우 이전 호출의 solution을 재사용해서 초기화 '', ''enumeration'':''''}, {''name'':''presort'', ''default'':''auto'', ''type'':''bool, string'', ''note'':''최적의 분할을 찾는 속도를 높이기 위해 데이터를 미리 정렬할지에 대한 여부 auto'', ''enumeration'':''auto''}, {''name'':''validation_fraction'', ''default'':''0.1'', ''type'':''float'', ''note'':''조기 중지를 위해 validation data로 따로 설정할 training data의 비율 '', ''enumeration'':''''}, {''name'':''n_iter_no_change'', ''default'':''None'', ''type'':''int'', ''note'':''유효성 검사 점수가 향상 되지 않을 때 조기 중지를 사용하여 교육을 종료할지에 대한 여부를 결정할 때 사용 '', ''enumeration'':''''}, {''name'':''tol'', ''default'':''0.0001'', ''type'':''float'', ''note'':''조기 중단에 대한 허용 오차 '', ''enumeration'':''''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like'', ''note'':''대상 값 [n_samples]''}, {''name'':''sample_weight'', ''default'':''None'', ''type'':''array-like'', ''note'':''샘플의 가중치 [n_samples], None''}, {''name'':''monitor'', ''default'':''None'', ''type'':''callable'', ''note'':''현재 iteration으로 각 iteration후에 moniter 호출, callable이 True를 반환하면 피팅 절차가 중단 ''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);
INSERT INTO public."ALGORITHM" VALUES (15, 'GradientBoostingRegressor', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingRegressor.html', 'ensemble', 'GradientBoostingRegressor', 'Gradient Boosting for regression', 'regression', '[{''name'':''loss'', ''default'':''ls'', ''type'':''string'', ''note'':''ls는 최소 제곱 회귀, lad는 최소 절대 편차(입력 변수의 순서 정보를 기반으로 함), huber는 앞에 둘의 조합을 loss 함수로 사용, quantile은 quantile회귀를 허용 ls,lad,huber,quantile'', ''enumeration'':''ls,lad,huber,quantile''}, {''name'':''learning_rate'', ''default'':''0.1'', ''type'':''float'', ''note'':''학습률 '', ''enumeration'':''''}, {''name'':''n_estimators'', ''default'':''100'', ''type'':''int'', ''note'':''수행 할 부스팅 단계 수 '', ''enumeration'':''''}, {''name'':''subsample'', ''default'':''1'', ''type'':''float'', ''note'':''개별 기본 학습자를 맞추는 데 사용되는 샘플의 비율, 1보다 작으면 Stochastic Gradient Boosting '', ''enumeration'':''''}, {''name'':''criterion'', ''default'':''friedman_mse'', ''type'':''string'', ''note'':''분할의 질을 측정하는 함수 friedman_mse,mse,mae'', ''enumeration'':''friedman_mse,mse,mae''}, {''name'':''min_samples_split'', ''default'':''2'', ''type'':''int, float'', ''note'':''내부 노드를 분할 하는데 필요한 최소 샘플 수 '', ''enumeration'':''''}, {''name'':''min_samples_leaf'', ''default'':''1'', ''type'':''int, float'', ''note'':''잎사귀 노드가 요구하는 최소 샘플 수 '', ''enumeration'':''''}, {''name'':''min_weight_fraction_leaf'', ''default'':''0'', ''type'':''float'', ''note'':''잎사귀 노드에 있어야 하는 (모든 입력 샘플의) 총 가중치의 최소 가중 비율 '', ''enumeration'':''''}, {''name'':''max_depth'', ''default'':''3'', ''type'':''int'', ''note'':''개별 회귀 추정기의 최대 깊이 '', ''enumeration'':''''}, {''name'':''min_impurity_decrease'', ''default'':''0'', ''type'':''float'', ''note'':''분할이 impurity을 지정한 값 이상으로 감소시키면 노드 분할 '', ''enumeration'':''''}, {''name'':''min_impurity_split'', ''default'':''None'', ''type'':''float'', ''note'':''나무의 빠른 중단에 대한 임계값 '', ''enumeration'':''''}, {''name'':''init'', ''default'':''None'', ''type'':''string'', ''note'':''초기 예측을 계산하는데 사용되는 추정기 zero,None'', ''enumeration'':''zero,None''}, {''name'':''random_state'', ''default'':''None'', ''type'':''int'', ''note'':''확률 추정을 위해 데이터를 섞을 때 사용되는 의사 난수 생성기의 시드, int는 난수 생성기에서 사용하는 seed, 만약 None이면 난수 생성기는 np.random에서 사용하는 인스턴스를 사용 '', ''enumeration'':''''}, {''name'':''max_features'', ''default'':''None'', ''type'':''int, float, string'', ''note'':''최적의 분할을 찾을 때 고려해야 할 features 수 auto,sqrt,log2,None'', ''enumeration'':''auto,sqrt,log2,None''}, {''name'':''alpha'', ''default'':''0.9'', ''type'':''float'', ''note'':''후버 손실 함수 및 양자 손실 함수의 알파 양자 '', ''enumeration'':''''}, {''name'':''verbose'', ''default'':''0'', ''type'':''int'', ''note'':''자세한 출력 사용 '', ''enumeration'':''''}, {''name'':''max_leaf_nodes'', ''default'':''None'', ''type'':''int'', ''note'':''잎사귀 노드의 성장 상한선 '', ''enumeration'':''''}, {''name'':''warm_start'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''True일 경우 이전 호출의 solution을 재사용해서 초기화 '', ''enumeration'':''''}, {''name'':''presort'', ''default'':''auto'', ''type'':''bool, string'', ''note'':''최적의 분할을 찾는 속도를 높이기 위해 데이터를 미리 정렬할지에 대한 여부 auto'', ''enumeration'':''auto''}, {''name'':''validation_fraction'', ''default'':''0.1'', ''type'':''float'', ''note'':''조기 중지를 위해 validation data로 따로 설정할 training data의 비율 '', ''enumeration'':''''}, {''name'':''n_iter_no_change'', ''default'':''None'', ''type'':''int'', ''note'':''유효성 검사 점수가 향상 되지 않을 때 조기 중지를 사용하여 교육을 종료할지에 대한 여부를 결정할 때 사용 '', ''enumeration'':''''}, {''name'':''tol'', ''default'':''0.0001'', ''type'':''float'', ''note'':''조기 중단에 대한 허용 오차 '', ''enumeration'':''''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like'', ''note'':''대상 값 [n_samples]''}, {''name'':''sample_weight'', ''default'':''None'', ''type'':''array-like'', ''note'':''샘플의 가중치 [n_samples], None''}, {''name'':''monitor'', ''default'':''None'', ''type'':''callable'', ''note'':''현재 iteration으로 각 iteration후에 moniter 호출, callable이 True를 반환하면 피팅 절차가 중단 ''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);
INSERT INTO public."ALGORITHM" VALUES (6, 'LogisticRegression', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html', 'linear_model', 'LogisticRegression', 'Logistic Regression', 'classification', '[{''name'':''penalty'', ''default'':''l2'', ''type'':''string'', ''note'':''penalization에 사용될 개념 l1,l2,elasticnet,None'', ''enumeration'':''l1,l2,elasticnet,None''}, {''name'':''dual'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''dual, primal형식, dual 형식은 l2 penalty에서만 구현 '', ''enumeration'':''''}, {''name'':''tol'', ''default'':''0.0001'', ''type'':''float'', ''note'':''중단에 대한 허용 오차 '', ''enumeration'':''''}, {''name'':''C'', ''default'':''1'', ''type'':''float'', ''note'':''정규화 강도의 역, 작을수록 더 강한 정규화 '', ''enumeration'':''''}, {''name'':''fit_intercept'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''결정 함수에 상수(bias)를 추가할지에 대한 여부 '', ''enumeration'':''''}, {''name'':''intercept_scaling'', ''default'':''1'', ''type'':''float'', ''note'':''x는 intercept_scaling과 동일한 상수 값을 가진 "합성"기능이 인스턴스 벡터에 추가, 솔버에 liblinear가 사용되고 fit_intercept가 True일 경우에만 유용 '', ''enumeration'':''''}, {''name'':''class_weight'', ''default'':''None'', ''type'':''dict, string'', ''note'':''{class_label : weight} 형식의 클래스와 연관된 가중치 balanced,None'', ''enumeration'':''balanced,None''}, {''name'':''random_state'', ''default'':''None'', ''type'':''int'', ''note'':''확률 추정을 위해 데이터를 섞을 때 사용되는 의사 난수 생성기의 시드, int는 난수 생성기에서 사용하는 seed, 만약 None이면 난수 생성기는 np.random에서 사용하는 인스턴스를 사용 '', ''enumeration'':''''}, {''name'':''solver'', ''default'':''warn'', ''type'':''string'', ''note'':''최적화 문제에 사용할 알고리즘 newton-cg,lbfgs,liblinear,sag,saga'', ''enumeration'':''newton-cg,lbfgs,liblinear,sag,saga''}, {''name'':''max_iter'', ''default'':''100'', ''type'':''int'', ''note'':''solver가 수렴하는데 걸린 최대 반복 횟수 '', ''enumeration'':''''}, {''name'':''multi_class'', ''default'':''warn'', ''type'':''string'', ''note'':''이진문제인지 다항문제인지를 결정 ovr,multinomial,auto'', ''enumeration'':''ovr,multinomial,auto''}, {''name'':''verbose'', ''default'':''0'', ''type'':''int'', ''note'':''liblinear 및 lbfgs 솔버의 경우 verbose를 자세한 양수로 설정 '', ''enumeration'':''''}, {''name'':''warm_start'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''True일 경우 이전 호출의 solution을 재사용해서 초기화 '', ''enumeration'':''''}, {''name'':''n_jobs'', ''default'':''None'', ''type'':''int'', ''note'':''multi_class = ovr인 경우 클래스를 병렬 처리 할 때 사용되는 CPU 코어 수 '', ''enumeration'':''''}, {''name'':''l1_ration'', ''default'':''None'', ''type'':''float'', ''note'':''0 <= l1_ratio <= 1 을 가지는 Elastic-Net의 혼합 매개변수, penalty=elasticnet, l1_ratio=0인 경우에만 사용 '', ''enumeration'':''''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like'', ''note'':''대상 값 [n_samples]''}, {''name'':''sample_weight'', ''default'':''None'', ''type'':''array-like'', ''note'':''각 샘플의 가중치 배열 [n_samples], None''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);
INSERT INTO public."ALGORITHM" VALUES (12, 'AdaBoostClassifier', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostClassifier.html', 'ensemble', 'AdaBoostClassifier', 'An AdaBoost classifier', 'classification', '[{''name'':''base_estimator'', ''default'':''None'', ''type'':''object'', ''note'':''부스트 앙상블이 만들어지는 기본 추정기, None일 경우 DecisionTreeClassifier(max_depth=1)이 기본 추정기 '', ''enumeration'':''''}, {''name'':''n_estimators'', ''default'':''50'', ''type'':''int'', ''note'':''부스팅이 종료되는 최대 추정량 '', ''enumeration'':''''}, {''name'':''learning_rate'', ''default'':''1'', ''type'':''float'', ''note'':''모델의 학습률 '', ''enumeration'':''''}, {''name'':''algorithm'', ''default'':''SAMME.R'', ''type'':''string'', ''note'':''모델에 적용하는 가중치를 계산하는 알고리즘 SAMME,SAMME.R'', ''enumeration'':''SAMME,SAMME.R''}, {''name'':''random_state'', ''default'':''None'', ''type'':''int'', ''note'':''확률 추정을 위해 데이터를 섞을 때 사용되는 의사 난수 생성기의 시드, int는 난수 생성기에서 사용하는 seed, 만약 None이면 난수 생성기는 np.random에서 사용하는 인스턴스를 사용 '', ''enumeration'':''''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like'', ''note'':''대상 값 [n_samples]''}, {''name'':''samples_weight'', ''default'':''None'', ''type'':''array-like'', ''note'':''샘플의 가중치 [n_samples], None''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);
INSERT INTO public."ALGORITHM" VALUES (1, 'DecisionTreeClassifier', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier', 'tree', 'DecisionTreeClassifier', 'Decision Tree for Classification', 'classification', '[{''name'':''criterion'', ''default'':''gini'', ''type'':''string'', ''note'':''분할의 질을 측정하는 함수 gini,entropy'', ''enumeration'':''gini,entropy''}, {''name'':''splitter'', ''default'':''best'', ''type'':''string'', ''note'':''노드의 분할을 결정하는 방법 best,random'', ''enumeration'':''best,random''}, {''name'':''max_depth'', ''default'':''None'', ''type'':''int'', ''note'':''트리의 최대 깊이 '', ''enumeration'':''''}, {''name'':''min_samples_split'', ''default'':''2'', ''type'':''int, float'', ''note'':''내부 노드를 분할 하는데 필요한 최소 샘플 수 '', ''enumeration'':''''}, {''name'':''min_samples_leaf'', ''default'':''1'', ''type'':''int, float'', ''note'':''잎사귀 노드가 요구하는 최소 샘플 수 '', ''enumeration'':''''}, {''name'':''min_weight_fraction_leaf'', ''default'':''0'', ''type'':''float'', ''note'':''잎사귀 노드에 있어야 하는 (모든 입력 샘플의) 총 가중치의 최소 가중 비율 '', ''enumeration'':''''}, {''name'':''max_features'', ''default'':''None'', ''type'':''int, float,string'', ''note'':''최적의 분할을 찾을 때 고려해야 할 features 수 auto,sqrt,log2,None'', ''enumeration'':''auto,sqrt,log2,None''}, {''name'':''random_state'', ''default'':''None'', ''type'':''int'', ''note'':''확률 추정을 위해 데이터를 섞을 때 사용되는 의사 난수 생성기의 시드, int는 난수 생성기에서 사용하는 seed, 만약 None이면 난수 생성기는 np.random에서 사용하는 인스턴스를 사용 '', ''enumeration'':''''}, {''name'':''max_leaf_nodes'', ''default'':''None'', ''type'':''int'', ''note'':''잎사귀 노드의 성장 상한선 '', ''enumeration'':''''}, {''name'':''min_impurity_decrease'', ''default'':''0'', ''type'':''float'', ''note'':''분할이 impurity을 지정한 값 이상으로 감소시키면 노드 분할 '', ''enumeration'':''''}, {''name'':''min_impurity_split'', ''default'':''None'', ''type'':''float'', ''note'':''나무의 빠른 중단에 대한 임계값 '', ''enumeration'':''''}, {''name'':''class_weight'', ''default'':''None'', ''type'':''dict, list of dict, string'', ''note'':''{class_label : weight} 형식의 클래스와 연관된 가중치 balanced,None'', ''enumeration'':''balanced,None''}, {''name'':''presort'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''최적의 분할을 찾는 속도를 높이기 위해 데이터를 미리 정렬할지에 대한 여부 '', ''enumeration'':''''}]', '[{''name'':''X'', ''default'':'''', ''type'':''array-like, sparse matrix'', ''note'':''학습용 입력 데이터 [n_samples, n_features]''}, {''name'':''y'', ''default'':'''', ''type'':''array-like'', ''note'':''대상 값 [n_samples], [n_samples, n_outputs]''}, {''name'':''sample_weight'', ''default'':''None'', ''type'':''array-like'', ''note'':''샘플의 가중치, None일 경우 샘플들은 같은 가중치를 갖음 [n_samples], None''}, {''name'':''check_input'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''input checking의 우회 여부 ''}, {''name'':''X_idx_sorted'', ''default'':''None'', ''type'':''array-like'', ''note'':''정렬된 학습용 입력 샘플의 색인 [n_samples, n_features]''}]', 'numeric, string', '2019-11-13 07:05:37.283073', 'daumsoft', true);


--
-- Data for Name: PREPROCESS_FUNCTION; Type: TABLE DATA; Schema: public; Owner: -
--

INSERT INTO public."PREPROCESS_FUNCTION" VALUES (7, 'MaxAbsScaler', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MaxAbsScaler.html', 'preprocessing', 'MaxAbsScaler', 'Scale each feature by its maximum absolute value.', 'Numerical conversion', '[{''name'':''copy'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''전체 스케일링을 수행하고 복사를 피하려면 False로 설정 '', ''enumerate'':''''}]', 'numeric, string', '2019-11-13 16:12:07.128095', 'daumsoft', true);
INSERT INTO public."PREPROCESS_FUNCTION" VALUES (6, 'MultiLabelBinarizer', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MultiLabelBinarizer.html', 'preprocessing', 'MultiLabelBinarizer', 'Transform between iterable of iterables and a multilabel format', 'Numerical conversion', '[{''name'':''classes'', ''default'':''None'', ''type'':''array'', ''note'':''클래스 레이블의 순서를 나타냄, 모든 항목은 고유해야 함 [n_class]'', ''enumerate'':''''}, {''name'':''sparse_output'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''출력 이진 배열을 CSR 스파스 형식으로 원하는 경우 True로 설정 '', ''enumerate'':''''}]', 'numeric, string', '2019-11-13 16:12:07.128095', 'daumsoft', true);
INSERT INTO public."PREPROCESS_FUNCTION" VALUES (5, 'LabelEncoder', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html', 'preprocessing', 'LabelEncoder', 'Encode labels with value between 0 and n_classes-1.', 'Numerical conversion', '[{''name'':'''', ''default'':'''', ''type'':'''', ''note'':'''', ''enumerate'':''''}]', 'numeric, string', '2019-11-13 16:12:07.128095', 'daumsoft', true);
INSERT INTO public."PREPROCESS_FUNCTION" VALUES (4, 'LabelBinarizer', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelBinarizer.html', 'preprocessing', 'LabelBinarizer', 'Binarize labels in a one-vs-all fashion', 'Numerical conversion', '[{''name'':''neg_label'', ''default'':''0'', ''type'':''int'', ''note'':''음수 레이블을 인코딩 해야 하는 값 '', ''enumerate'':''''}, {''name'':''pos_label'', ''default'':''1'', ''type'':''int'', ''note'':''양수 레이블을 인코딩 해야 하는 값 '', ''enumerate'':''''}, {''name'':''sparse_output'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''변환으로 부터 반환된 array가 희소한 CSR형식이면 True '', ''enumerate'':''''}]', 'numeric, string', '2019-11-13 16:12:07.128095', 'daumsoft', true);
INSERT INTO public."PREPROCESS_FUNCTION" VALUES (3, 'KBinsDiscretizer', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.KBinsDiscretizer.html', 'preprocessing', 'KBinsDiscretizer', 'Bin continuous data into intervals.', 'Reduce range', '[{''name'':''n_bins'', ''default'':''5'', ''type'':''int, array-like'', ''note'':''생산할 bins의 수 [n_features,]'', ''enumerate'':''''}, {''name'':''encode'', ''default'':''onehot'', ''type'':''string'', ''note'':''변환 된 결과를 인코딩 하는데 사용되는 방법 onehot,onehot-dense,ordinal'', ''enumerate'':''onehot,onehot-dense,ordinal''}, {''name'':''strategy'', ''default'':''quantile'', ''type'':''string'', ''note'':''bins의 너비를 정의하는데 사용되는 전략 quantile,uniform,kmeans'', ''enumerate'':''quantile,uniform,kmeans''}]', 'numeric, string', '2019-11-13 16:12:07.128095', 'daumsoft', true);
INSERT INTO public."PREPROCESS_FUNCTION" VALUES (2, 'Binarizer', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Binarizer.html', 'preprocessing', 'Binarizer', 'Binarize data (set feature values to 0 or 1) according to a threshold', 'Reduce range', '[{''name'':''threshold'', ''default'':''0'', ''type'':''float'', ''note'':''이보다 작거나 같은 값은 0으로, 큰 값은 1로 대체 '', ''enumerate'':''''}, {''name'':''copy'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''내부 이진화를 수행하며 복사를 피하려면 False로 설정 '', ''enumerate'':''''}]', 'numeric, string', '2019-11-13 16:12:07.128095', 'daumsoft', true);
INSERT INTO public."PREPROCESS_FUNCTION" VALUES (11, 'OrdinalEncoder', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OrdinalEncoder.html', 'preprocessing', 'OrdinalEncoder', 'Encode categorical features as an integer array.', 'Numerical conversion', '[{''name'':''categories'', ''default'':''auto'', ''type'':''string, list of lists, array'', ''note'':''features 별 카테고리 (고유 값) auto'', ''enumerate'':''auto''}]', 'numeric, string', '2019-11-13 16:12:07.128095', 'daumsoft', true);
INSERT INTO public."PREPROCESS_FUNCTION" VALUES (1, 'SimpleImputer', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html', 'impute', 'SimpleImputer', 'Imputation transformer for completing missing values.', 'Missing value substitution', '[{''name'':''missing_values'', ''default'':''nan'', ''type'':''numerical, string, np.nan'', ''note'':''결측값에 대한 placeholder, 모든 결측값의 발생이 대치 '', ''enumerate'':''''}, {''name'':''strategy'', ''default'':''mean'', ''type'':''string'', ''note'':''imputation 전략 '', ''enumerate'':''mean,median,most_frequent,constant''}, {''name'':''fill_value'', ''default'':''None'', ''type'':''string, numerical'', ''note'':''strategy == constant일 때 fill_value는 결측값의 발생을 대체 '', ''enumerate'':''''}, {''name'':''verbose'', ''default'':''0'', ''type'':''int'', ''note'':''imputer의 자세한 내용을 제어 '', ''enumerate'':''''}, {''name'':''copy'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''True인 경우 X의 사본이 생성 됨 '', ''enumerate'':''''}, {''name'':''add_indicator'', ''default'':''FALSE'', ''type'':''bool'', ''note'':''True인 경우 MissingIndicator 변환은 imputer의 변환의 결과에 쌓음 '', ''enumerate'':''''}]', 'numeric, string', '2019-11-13 16:12:07.128095', 'daumsoft', true);
INSERT INTO public."PREPROCESS_FUNCTION" VALUES (14, 'DropColumns', 'pandas', '0.25.0', 'https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html', 'not_applicable', 'not_applicable', 'Remove column', 'drop columns from dataframe', '[{''name'':'''', ''default'':'''', ''type'':'''', ''note'':'''', ''enumerate'':''''}]', 'dataframe', '2019-11-13 16:12:07.128095', 'daumsoft', true);
INSERT INTO public."PREPROCESS_FUNCTION" VALUES (13, 'StandardScaler', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html', 'preprocessing', 'StandardScaler', 'Standardize features by removing the mean and scaling to unit variance', 'Scaling', '[{''name'':''copy'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''False인 경우 복사를 피하고 스케일을 조정 '', ''enumerate'':''''}, {''name'':''with_mean'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''true인 경우 스케일링 전 데이터를 중심에 둠 '', ''enumerate'':''''}, {''name'':''with_std'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''true인 경우 데이터를 단위 분산으로 조정 '', ''enumerate'':''''}]', 'numeric, string', '2019-11-13 16:12:07.128095', 'daumsoft', true);
INSERT INTO public."PREPROCESS_FUNCTION" VALUES (12, 'RobustScaler', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html', 'preprocessing', 'RobustScaler', 'Scale features using statistics that are robust to outliers.', 'Scaling', '[{''name'':''with_centering'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''true인 경우 스케일링 전 데이터를 중심에 둠 '', ''enumerate'':''''}, {''name'':''with_scaling'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''true인 경우 데이터를 사분위수 범위로 조정 '', ''enumerate'':''''}, {''name'':''quantile_range'', ''default'':''(25.0, 75.0)'', ''type'':''tuple'', ''note'':''scale_을 계산하는 데 사용되는 IQR Quantile 범위 0보다 크며 100보다 작음 (q_min, q_max)'', ''enumerate'':''''}, {''name'':''copy'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''False인 경우 복사를 피하고 스케일을 조정 '', ''enumerate'':''''}]', 'numeric, string', '2019-11-13 16:12:07.128095', 'daumsoft', true);
INSERT INTO public."PREPROCESS_FUNCTION" VALUES (9, 'Normalizer', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Normalizer.html', 'preprocessing', 'Normalizer', 'Normalize samples individually to unit norm.', 'Scaling', '[{''name'':''norm'', ''default'':''l2'', ''type'':''string'', ''note'':''0이 아닌 각 샘플을 정규화하는 데 사용되는 표준 (l1, l2, max)'', ''enumerate'':''l1, l2, max''}, {''name'':''copy'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''전체 스케일링을 수행하고 복사를 피하려면 False로 설정 '', ''enumerate'':''''}]', 'numeric, string', '2019-11-13 16:12:07.128095', 'daumsoft', true);
INSERT INTO public."PREPROCESS_FUNCTION" VALUES (8, 'MinMaxScaler', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html', 'preprocessing', 'MinMaxScaler', 'Transforms features by scaling each feature to a given range.', 'Scaling', '[{''name'':''feature_range'', ''default'':''(0, 1)'', ''type'':''tuple'', ''note'':''변형된 데이터의 원하는 범위 [min, max]'', ''enumerate'':''''}, {''name'':''copy'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''전체 스케일링을 수행하고 복사를 피하려면 False로 설정 '', ''enumerate'':''''}]', 'numeric, string', '2019-11-13 16:12:07.128095', 'daumsoft', true);
INSERT INTO public."PREPROCESS_FUNCTION" VALUES (10, 'OneHotEncoder', 'sklearn', '0.21.3', 'https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html', 'preprocessing', 'OneHotEncoder', 'Encode categorical integer features as a one-hot numeric array.', 'Numerical conversion', '[{''name'':''n_values'', ''default'':''auto'', ''type'':''string, int, array'', ''note'':''features 별 값 수  auto'', ''enumerate'':''auto''}, {''name'':''categorical_features'', ''default'':''all'', ''type'':''string, array'', ''note'':''범주로 취급되는 features을 지정 all'', ''enumerate'':''all''}, {''name'':''categories'', ''default'':''auto'', ''type'':''string, list of list, array'', ''note'':''features 별 카테고리 (고유 값) auto'', ''enumerate'':''auto''}, {''name'':''drop'', ''default'':''None'', ''type'':''string, list, array'', ''note'':''features 당 카테고리 중 하나를 삭제하는 데 사용 할 방법 지정 [n_features,]'', ''enumerate'':''None,first''}, {''name'':''sparse'', ''default'':''TRUE'', ''type'':''bool'', ''note'':''True로 설정하면 희소 행렬을 반환하고 그렇지 않으면 배열을 반환 '', ''enumerate'':''''}, {''name'':''handle_unknown'', ''default'':''error'', ''type'':''string'', ''note'':''변환 중에 알수 없는 범주형 feature가 있는 경우 오류를 발생할지 무시할지에 대한 여부 error,ignore'', ''enumerate'':''error,ignore''}]', 'numeric, string', '2019-11-13 16:12:07.128095', 'daumsoft', true);
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A005001', '배치 시작', '배치를 시작한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A005002', '예측용 데이터 파일 확인', '예측용 데이터 파일을 확인한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A005003', '배치 모듈 실행', '배치 모듈을 실행한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A005004', '배치 모듈 결과', '배치 모듈 실행 결과를 확인한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A005005', '결과 저장(코어모듈)', '배치 실행 결과를 코어모듈에 저장/확인한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A005006', '배치 종료', '배치를 완료한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A001', '관리자 배치서버관리', '관리자에 의한 배치서버의 시작, 중지, 상태이상 등을 의미한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A003', '관리자 배치등록,수정,삭제 관리', '관리자에 의한 배치 등록, 수정, 삭제를 의미한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A004', '관리자 주기 배치작업 명령 실행', '관리자에 의한 주기적인 배치작업 시작, 종료 명령을을 의미한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A005', '배치 스케줄링 작업', '배치관리서버에 의한 배치작업에 대한 스케줄링을 작업을 의미한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A001002', '배치서버 시작', '관리자에 의해 배치 서버를 시작한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A001003', '배치서버 중지', '관리자에 의해 배치 서버를 중지한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A001004', '배치서버 상태이상', '배치서버의 상태에 문제를 가지고 있다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A002001', '사용자 배치요청 등록', '사용자가 배치등록을 요청한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A002002', '사용자 배치요청 수정', '사용자가 배치수정을 한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A002003', '사용자 배치요청 삭제', '사용자가 배치삭제를 한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A003001', '관리자 배치정보 등록', '관리자가 배치정보를 등록한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A003003', '관리자 배치정보 수정', '관리자가 배치정보를 수정한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A003004', '관리자 배치정보 삭제', '관리자가 배치정보를 삭제한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A004001', '관리자 배치주기작업 시작 명령', '관리자가 배치주기작업 시작 명령을 내린다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A004002', '관리자 배치주기작업 중지 명령', '관리자가 배치주기작업 중지 명령을 내린다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A005001', '배치 시작', '배치를 시작한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A005002', '예측용 데이터 파일 확인', '예측용 데이터 파일을 확인한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A005003', '배치 모듈 실행', '배치 모듈을 실행한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A005004', '배치 모듈 결과', '배치 모듈 실행 결과를 확인한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A005005', '결과 저장(코어모듈)', '배치 실행 결과를 코어모듈에 저장/확인한다.');
INSERT INTO public."CODE" ("CODE",  "CODE_NAME", "DESCRIPTION") VALUES ('A005006', '배치 종료', '배치를 완료한다.');

--
-- PostgreSQL database dump complete
--

